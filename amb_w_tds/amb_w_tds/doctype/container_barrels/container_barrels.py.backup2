# Copyright (c) 2024, AMB Wellness and contributors
# For license information, please see license.txt

import frappe
from frappe import _
from frappe.model.document import Document
import re
import json

class ContainerBarrels(Document):
    def validate(self):
        """Validate barrel on save"""
        if self.serial_no:
            self.validate_serial_format()
            self.check_duplicate_serial()
    
    def validate_serial_format(self):
        """Validate serial number format"""
        if not validate_serial_format(self.serial_no):
            frappe.throw(_("Invalid serial format. Expected: AMB-2024-B001-0001"))
    
    def check_duplicate_serial(self):
        """Check for duplicate serial numbers"""
        existing = frappe.db.exists(
            "Container Barrels",
            {
                "serial_no": self.serial_no,
                "name": ["!=", self.name]
            }
        )
        if existing:
            frappe.throw(_("Serial number {0} already exists").format(self.serial_no))


# Validation Functions

def validate_serial_format(serial_no):
    """
    Validates serial number format
    Expected format: [PREFIX]-[YYYY]-[BATCH]-[NUMBER]
    Example: AMB-2024-B001-0001
    """
    if not serial_no:
        return False
    
    # Pattern: 3 letters, 4 digits, letter+3 digits, 4 digits
    pattern = r'^[A-Z]{3}-\d{4}-[A-Z]\d{3}-\d{4}$'
    return bool(re.match(pattern, str(serial_no).strip()))


@frappe.whitelist()
def validate_serial_number(serial_no):
    """
    Real-time validation endpoint
    Returns: {valid: bool, message: str, exists: bool, data: dict}
    """
    try:
        serial_no = str(serial_no).strip()
        
        # Format validation
        if not validate_serial_format(serial_no):
            return {
                "valid": False,
                "exists": False,
                "message": "Invalid serial format. Expected: AMB-2024-B001-0001"
            }
        
        # Check existence
        barrel_name = frappe.db.get_value(
            "Container Barrels",
            {"serial_no": serial_no},
            "name"
        )
        
        if barrel_name:
            # Get barrel details
            barrel = frappe.get_doc("Container Barrels", barrel_name)
            
            return {
                "valid": True,
                "exists": True,
                "message": "Serial found",
                "data": {
                    "name": barrel.name,
                    "serial_no": barrel.serial_no,
                    "status": barrel.get("barrel_status") or "Unknown",
                    "usage_count": barrel.get("usage_count") or 0,
                    "max_reuse_count": barrel.get("max_reuse_count") or 10,
                    "parent": barrel.parent,
                    "parent_type": barrel.parenttype
                }
            }
        else:
            return {
                "valid": True,
                "exists": False,
                "message": "Serial format valid but not found in system",
                "data": None
            }
            
    except Exception as e:
        frappe.log_error(f"Error validating serial {serial_no}: {str(e)}")
        return {
            "valid": False,
            "exists": False,
            "message": str(e)
        }


@frappe.whitelist()
def check_serial_availability(serial_no):
    """
    Check if serial is available for use
    Returns: {available: bool, reason: str, barrel: dict}
    """
    try:
        barrel = frappe.db.get_value(
            "Container Barrels",
            {"serial_no": serial_no},
            ["name", "serial_no", "barrel_status", "usage_count", "max_reuse_count"],
            as_dict=True
        )
        
        if not barrel:
            return {
                "available": False,
                "reason": "Serial not found in system"
            }
        
        # Check status
        status = barrel.get("barrel_status", "New")
        if status in ["In Use", "Cleaning", "Retired"]:
            return {
                "available": False,
                "reason": f"Barrel is currently {status}",
                "barrel": barrel
            }
        
        # Check usage count
        usage_count = barrel.get("usage_count", 0)
        max_reuse = barrel.get("max_reuse_count", 10)
        
        if usage_count >= max_reuse:
            return {
                "available": False,
                "reason": f"Maximum reuse limit reached ({usage_count}/{max_reuse})",
                "barrel": barrel
            }
        
        return {
            "available": True,
            "reason": "Barrel available for use",
            "barrel": barrel,
            "remaining_uses": max_reuse - usage_count
        }
        
    except Exception as e:
        frappe.log_error(f"Error checking availability for {serial_no}: {str(e)}")
        return {
            "available": False,
            "reason": f"Error: {str(e)}"
        }


@frappe.whitelist()
def bulk_validate_serials(serial_numbers):
    """
    Validate multiple serials at once
    Args: serial_numbers - list or JSON string of serial numbers
    Returns: {valid: [], invalid: [], duplicates: [], details: {}}
    """
    try:
        # Parse input
        if isinstance(serial_numbers, str):
            serial_numbers = json.loads(serial_numbers)
        
        if not isinstance(serial_numbers, list):
            return {
                "valid": [],
                "invalid": [],
                "duplicates": [],
                "details": {},
                "error": "Input must be a list of serial numbers"
            }
        
        results = {
            "valid": [],
            "invalid": [],
            "duplicates": [],
            "details": {},
            "summary": {
                "total": len(serial_numbers),
                "valid_count": 0,
                "invalid_count": 0,
                "duplicate_count": 0
            }
        }
        
        seen = set()
        
        for serial in serial_numbers:
            serial = str(serial).strip()
            
            # Check duplicates in input list
            if serial in seen:
                results["duplicates"].append(serial)
                results["summary"]["duplicate_count"] += 1
                results["details"][serial] = {
                    "valid": False,
                    "message": "Duplicate in input list"
                }
                continue
            
            seen.add(serial)
            
            # Validate each serial
            validation = validate_serial_number(serial)
            
            if validation["valid"]:
                results["valid"].append(serial)
                results["summary"]["valid_count"] += 1
            else:
                results["invalid"].append(serial)
                results["summary"]["invalid_count"] += 1
            
            results["details"][serial] = validation
        
        return results
        
    except Exception as e:
        frappe.log_error(f"Error in bulk validation: {str(e)}")
        return {
            "valid": [],
            "invalid": [],
            "duplicates": [],
            "details": {},
            "error": str(e)
        }


@frappe.whitelist()
def get_serial_info(serial_no):
    """
    Get detailed information about a serial number
    """
    try:
        validation = validate_serial_number(serial_no)
        
        if not validation["exists"]:
            return validation
        
        availability = check_serial_availability(serial_no)
        
        return {
            "valid": validation["valid"],
            "exists": validation["exists"],
            "barrel": validation["data"],
            "availability": availability,
            "message": validation["message"]
        }
        
    except Exception as e:
        frappe.log_error(f"Error getting serial info for {serial_no}: {str(e)}")
        return {
            "valid": False,
            "message": str(e)
        }


@frappe.whitelist()
def validate_and_get_available_serials(serial_numbers):
    """
    Validate serials and return only available ones
    """
    try:
        if isinstance(serial_numbers, str):
            serial_numbers = json.loads(serial_numbers)
        
        available = []
        unavailable = []
        
        for serial in serial_numbers:
            serial = str(serial).strip()
            
            validation = validate_serial_number(serial)
            if not validation["valid"] or not validation["exists"]:
                unavailable.append({
                    "serial": serial,
                    "reason": validation["message"]
                })
                continue
            
            availability = check_serial_availability(serial)
            if availability["available"]:
                available.append({
                    "serial": serial,
                    "barrel": availability["barrel"],
                    "remaining_uses": availability.get("remaining_uses", 0)
                })
            else:
                unavailable.append({
                    "serial": serial,
                    "reason": availability["reason"]
                })
        
        return {
            "available": available,
            "unavailable": unavailable,
            "summary": {
                "total": len(serial_numbers),
                "available_count": len(available),
                "unavailable_count": len(unavailable)
            }
        }
        
    except Exception as e:
        frappe.log_error(f"Error in validate_and_get_available_serials: {str(e)}")
        return {
            "available": [],
            "unavailable": [],
            "error": str(e)
        }
