"""
‚öôÔ∏è Migration Engine Module - LIGHTNING FAST VERSION
Minimal overhead, maximum performance
"""

import click
import frappe
import os
import shutil
import subprocess
import time
from pathlib import Path
from frappe.utils import get_sites

def clone_app_fast(app_name, session_id=None):
    """ULTRA FAST app cloning - minimal overhead"""
    print(f"üöÄ CLONING APP (FAST MODE): {app_name}")
    start_time = time.time()
    
    try:
        # MINIMAL SESSION OVERHEAD - Only update at start/end
        session = None
        if session_id:
            from ..utils.session import MigrationSession
            session = MigrationSession("temp-name", session_id)
            # Only one update at start
            session.update_progress(f"start_clone_{app_name}", "started")
        
        # FAST BENCH DETECTION
        benches = detect_available_benches()
        if len(benches) < 2:
            print("‚ùå Need at least 2 benches")
            return False
        
        # FAST SOURCE/TARGET DETECTION
        source_bench, target_bench = find_migration_path(app_name, benches)
        if not source_bench or not target_bench:
            return False
        
        print(f"üîÄ MIGRATION PATH: {source_bench} ‚Üí {target_bench}")
        
        # ULTRA FAST EXECUTION - Single command, no real-time output
        source_path = f"/home/frappe/{source_bench}/apps/{app_name}"
        target_bench_path = f"/home/frappe/{target_bench}"
        
        print(f"‚ö° EXECUTING ULTRA-FAST CLONE...")
        
        # SINGLE COMMAND: Clone + Install in one go
        command = f"""
        cd {target_bench_path} && 
        bench get-app {app_name} {source_path} && 
        bench --site all install-app {app_name}
        """
        
        print(f"   Command: bench get-app {app_name} && bench install-app {app_name}")
        
        # FAST EXECUTION: Run with timeout, minimal output processing
        try:
            result = subprocess.run(
                command,
                shell=True,
                capture_output=True,
                text=True,
                timeout=600,  # 10 minute timeout
                executable='/bin/bash'
            )
            
            execution_time = time.time() - start_time
            print(f"‚è±Ô∏è  Execution time: {execution_time:.2f} seconds")
            
            if result.returncode == 0:
                print(f"‚úÖ SUCCESS: {app_name} migrated in {execution_time:.2f}s")
                
                # FAST VERIFICATION
                target_apps = get_bench_apps(target_bench_path)
                if app_name in target_apps:
                    print(f"‚úÖ VERIFIED: {app_name} in target bench")
                    
                    # MINIMAL SESSION UPDATE - Only on success
                    if session:
                        session.update_progress(f"complete_clone_{app_name}", "completed")
                        session.mark_app_completed(app_name)
                    
                    return True
                else:
                    print(f"‚ùå VERIFICATION FAILED: {app_name} not found")
                    return False
            else:
                print(f"‚ùå COMMAND FAILED: {result.stderr}")
                return False
                
        except subprocess.TimeoutExpired:
            print(f"‚ùå TIMEOUT: Command took longer than 10 minutes")
            return False
            
    except Exception as e:
        print(f"‚ùå UNEXPECTED ERROR: {e}")
        import traceback
        traceback.print_exc()
        return False

def find_migration_path(app_name, benches):
    """Fast path finding without multiple bench queries"""
    source_bench = None
    target_bench = None
    
    # Single pass through benches
    bench_apps_cache = {}
    for bench in benches:
        bench_apps_cache[bench] = get_bench_apps(f"/home/frappe/{bench}")
        if app_name in bench_apps_cache[bench]:
            source_bench = bench
    
    if not source_bench:
        print(f"‚ùå App '{app_name}' not found")
        return None, None
    
    # Find target (first bench without the app)
    for bench in benches:
        if bench != source_bench and app_name not in bench_apps_cache[bench]:
            target_bench = bench
            break
    
    if not target_bench:
        print(f"‚ùå All benches have {app_name}")
        return None, None
    
    return source_bench, target_bench

def detect_available_benches():
    """Fast bench detection"""
    benches = []
    frappe_home = os.path.expanduser('~')
    
    for item in os.listdir(frappe_home):
        if item.startswith('frappe-bench') and os.path.isdir(os.path.join(frappe_home, item)):
            benches.append(item)
    
    return sorted(benches)

def get_bench_apps(bench_path):
    """Fast app detection with cache potential"""
    try:
        result = subprocess.run(
            f"cd {bench_path} && bench version",
            shell=True, capture_output=True, text=True, timeout=10
        )
        lines = result.stdout.strip().split('\n')
        apps = []
        for line in lines:
            if ' ' in line and not line.startswith('‚úÖ'):
                app = line.split()[0]
                apps.append(app)
        return sorted(apps)
    except Exception as e:
        print(f"   ‚ùå Error getting apps from {bench_path}: {e}")
        return []

# Keep original function for compatibility
def clone_app(app_name, session_id=None):
    """Wrapper for fast version"""
    return clone_app_fast(app_name, session_id)
