# app_migrator/__init__.py - COMPLETE SINGLE FILE
import click
import frappe
from frappe.utils import get_sites
import os
import shutil
import json
import re
import subprocess
import sys
from pathlib import Path

__version__ = "3.0.0"
app_name = "app_migrator"
app_title = "App Migrator"
app_publisher = "Frappe Community"
app_description = "Frappe App Migration Toolkit - SAFE COPY STRATEGY + TECHNICAL SPEC"
app_email = "fcrm@amb-wellness.com"
app_license = "mit"

# ========== SESSION MANAGEMENT ==========
def ensure_frappe_connection():
    try:
        frappe.db.sql("SELECT 1")
        return True
    except Exception:
        try:
            sites = get_sites()
            site = sites[0] if sites else None
            if site:
                frappe.init_site(site)
                frappe.connect(site=site)
                print("   üîÑ Session reconnected")
                return True
        except Exception as e:
            print(f"   ‚ùå Failed to reconnect: {e}")
            return False
    return False

def with_session_management(func):
    def wrapper(*args, **kwargs):
        try:
            if not ensure_frappe_connection():
                print("‚ùå Cannot establish Frappe connection")
                return None
            result = func(*args, **kwargs)
            frappe.db.commit()
            return result
        except Exception as e:
            print(f"‚ùå Session error in {func.__name__}: {e}")
            try:
                print("   üîÑ Attempting recovery...")
                if ensure_frappe_connection():
                    result = func(*args, **kwargs)
                    frappe.db.commit()
                    return result
            except Exception as retry_error:
                print(f"   ‚ùå Recovery failed: {retry_error}")
            return None
    return wrapper

# ========== CORE MIGRATION FUNCTIONS ==========
@with_session_management
def migrate_app_modules_copy(source_app, target_app, modules=None):
    print(f"üõ°Ô∏è SAFE COPY MODULES: {source_app} ‚Üí {target_app}")
    
    try:
        source_modules = frappe.get_all('Module Def', 
            filters={'app_name': source_app},
            fields=['name', 'module_name', 'app_name']
        )
        
        if modules:
            module_list = [m.strip() for m in modules.split(',')]
            source_modules = [m for m in source_modules if m['module_name'] in module_list]
        
        print(f"üì¶ Found {len(source_modules)} modules in {source_app}")
        
        if not source_modules:
            print("‚ùå No modules found to copy")
            return False
        
        duplicate_modules = []
        core_modules = []
        safe_to_copy_modules = []
        
        for module in source_modules:
            module_name = module['module_name']
            
            if module_name.lower() == 'core':
                core_modules.append(module_name)
                continue
                
            if frappe.db.exists('Module Def', {'module_name': module_name, 'app_name': target_app}):
                duplicate_modules.append(module_name)
            else:
                safe_to_copy_modules.append(module)
        
        if duplicate_modules:
            print(f"‚ö†Ô∏è  DUPLICATES FOUND ({len(duplicate_modules)} will be skipped): {', '.join(duplicate_modules)}")
        
        if core_modules:
            print(f"üö´ CORE MODULES ({len(core_modules)} will be skipped): {', '.join(core_modules)}")
        
        print(f"‚úÖ SAFE TO COPY: {len(safe_to_copy_modules)} modules")
        
        if not safe_to_copy_modules:
            print("üö´ No modules to copy")
            return False
            
        if safe_to_copy_modules:
            copy_list = [m['module_name'] for m in safe_to_copy_modules]
            print(f"üìã WILL COPY: {', '.join(copy_list)}")
        
        confirm = input(f"‚ö†Ô∏è  COPY {len(safe_to_copy_modules)} modules from {source_app} to {target_app}? (y/N): ").strip().lower()
        if confirm != 'y':
            print("üö´ Copy operation cancelled")
            return False
        
        copied_count = 0
        skipped_count = len(duplicate_modules) + len(core_modules)
        
        for module in safe_to_copy_modules:
            try:
                new_module = frappe.get_doc({
                    'doctype': 'Module Def',
                    'module_name': module['module_name'],
                    'app_name': target_app
                })
                new_module.insert(ignore_permissions=True)
                print(f"   ‚úÖ COPIED module: {module['module_name']} to {target_app}")
                copied_count += 1
                    
            except Exception as e:
                print(f"   ‚ùå Failed to copy module '{module['module_name']}': {str(e)[:100]}...")
                skipped_count += 1
        
        frappe.db.commit()
        print(f"üéâ SAFE COPY COMPLETED: {copied_count} copied, {skipped_count} skipped")
        
        successful_modules = [m['module_name'] for m in safe_to_copy_modules if frappe.db.exists('Module Def', {'module_name': m['module_name'], 'app_name': target_app})]
        if successful_modules:
            copy_module_files_safe(source_app, target_app, successful_modules)
        else:
            print("üí° No module files to copy")
            
        return copied_count > 0
            
    except Exception as e:
        print(f"‚ùå Copy migration failed: {e}")
        import traceback
        traceback.print_exc()
        return False

def copy_module_files_safe(source_app, target_app, modules):
    print(f"üìÅ SAFE COPY FILES: {source_app} ‚Üí {target_app}")
    
    try:
        bench_path = Path('/home/frappe/frappe-bench')
        source_app_path = bench_path / 'apps' / source_app / source_app
        target_app_path = bench_path / 'apps' / target_app / target_app
        
        if not source_app_path.exists():
            print(f"‚ùå Source app path not found: {source_app_path}")
            return
        
        if not target_app_path.exists():
            print(f"‚ùå Target app path not found: {target_app_path}")
            return
        
        copied_count = 0
        skipped_count = 0
        
        for module in modules:
            if module.lower() == 'core':
                print(f"   üö´ SKIPPED: Core module files")
                skipped_count += 1
                continue
                
            module_path = source_app_path / module
            target_module_path = target_app_path / module
            
            if module_path.exists():
                if target_module_path.exists():
                    print(f"   ‚ö†Ô∏è  Target module exists, skipping: {module}")
                    skipped_count += 1
                else:
                    shutil.copytree(str(module_path), str(target_module_path))
                    print(f"   ‚úÖ COPIED {module} files")
                    copied_count += 1
            else:
                print(f"   ‚ö†Ô∏è  Module directory not found: {module_path}")
                skipped_count += 1
        
        print(f"üéâ SAFE FILE COPY COMPLETED: {copied_count} copied, {skipped_count} skipped")
        
    except Exception as e:
        print(f"‚ùå Safe file copy failed: {e}")

@with_session_management
def analyze_safe_copy_compatibility(source_app, target_app):
    print(f"üîç SAFE COPY COMPATIBILITY: {source_app} ‚Üí {target_app}")
    
    try:
        source_modules = frappe.get_all('Module Def', 
            filters={'app_name': source_app},
            fields=['module_name']
        )
        
        target_modules = frappe.get_all('Module Def',
            filters={'app_name': target_app}, 
            fields=['module_name']
        )
        
        source_module_names = [m['module_name'] for m in source_modules]
        target_module_names = [m['module_name'] for m in target_modules]
        
        conflicts = set(source_module_names) & set(target_module_names)
        core_modules = [m for m in source_module_names if m.lower() == 'core']
        
        print(f"üìä COMPATIBILITY ANALYSIS:")
        print(f"   ‚Ä¢ Source modules: {len(source_modules)}")
        print(f"   ‚Ä¢ Target modules: {len(target_modules)}")
        print(f"   ‚Ä¢ Module conflicts: {len(conflicts)}")
        print(f"   ‚Ä¢ Core modules found: {len(core_modules)}")
        
        if conflicts:
            print(f"   ‚ö†Ô∏è  CONFLICTS (will be skipped):")
            for conflict in sorted(conflicts):
                print(f"     ‚Ä¢ {conflict}")
        
        if core_modules:
            print(f"   üö´ CORE MODULES (will be skipped):")
            for core_mod in core_modules:
                print(f"     ‚Ä¢ {core_mod}")
        
        safe_to_copy = len(source_modules) - len(conflicts) - len(core_modules)
        print(f"   ‚úÖ SAFE TO COPY: {safe_to_copy} modules")
        
        return safe_to_copy > 0
        
    except Exception as e:
        print(f"‚ùå Compatibility analysis failed: {e}")
        return False

# ========== TECHNICAL SPEC ENHANCEMENTS ==========
class TechnicalSpecAnalyzer:
    def __init__(self, site_name=None):
        # FIX: Handle case where frappe.local.site is not available
        try:
            self.site_name = site_name or frappe.local.site
        except AttributeError:
            # If frappe.local.site is not available, use the first site
            sites = get_sites()
            self.site_name = site_name or (sites[0] if sites else 'unknown')
    
    @with_session_management
    def analyze_risks(self):
        """Risk analysis with session management"""
        print("üîç TECHNICAL SPEC RISK ANALYSIS")
        
        analysis = {
            'customizations': self._detect_all_customizations(),
            'risk_assessment': self._assess_all_risks(),
            'high_risk_items': []
        }
        
        analysis['high_risk_items'] = [
            item for item in analysis['risk_assessment'] 
            if item['risk_level'] in ['CRITICAL', 'HIGH']
        ]
        
        return analysis
    
    def _detect_all_customizations(self):
        """Detect customizations with error handling"""
        try:
            return {
                'custom_fields': frappe.get_all('Custom Field', 
                    fields=['dt', 'fieldname', 'fieldtype', 'reqd']),
                'property_setters': frappe.get_all('Property Setter',
                    fields=['doc_type', 'field_name', 'property', 'value']),
                'custom_doctypes': frappe.get_all('DocType', 
                    filters={'custom': 1}, 
                    fields=['name', 'module']),
                'installed_apps': frappe.get_installed_apps()
            }
        except Exception as e:
            print(f"‚ùå Error detecting customizations: {e}")
            return {
                'custom_fields': [],
                'property_setters': [],
                'custom_doctypes': [],
                'installed_apps': []
            }
    
    def _assess_all_risks(self):
        """Assess risks with error handling"""
        try:
            risks = []
            customizations = self._detect_all_customizations()
            
            for doctype in customizations['custom_doctypes']:
                risk_level = self._classify_risk(doctype)
                
                risks.append({
                    'item': doctype['name'],
                    'type': 'Custom DocType',
                    'module': doctype['module'],
                    'risk_level': risk_level,
                    'mitigation': self._get_mitigation(risk_level)
                })
            
            return risks
        except Exception as e:
            print(f"‚ùå Error assessing risks: {e}")
            return []
    
    def _classify_risk(self, doctype):
        name = doctype['name'].lower()
        module = doctype['module'].lower()
        
        if any(keyword in module or keyword in name for keyword in ['fda', 'compliance', 'regulatory']):
            return 'CRITICAL'
        elif 'core' in module:
            return 'HIGH'
        else:
            return 'MEDIUM'
    
    def _get_mitigation(self, risk_level):
        strategies = {
            'CRITICAL': 'Test in staging, user sign-off required',
            'HIGH': 'Phased migration, dependency mapping',
            'MEDIUM': 'Standard testing procedures',
            'LOW': 'Basic validation'
        }
        return strategies.get(risk_level, 'Standard procedures')
    
    @with_session_management
    def create_backup(self):
        """Create backup with session management"""
        print("üíæ CREATING BACKUP...")
        try:
            cmd = f"cd /home/frappe/frappe-bench && bench --site {self.site_name} backup --with-files"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                print("‚úÖ Backup created successfully")
                return True
            else:
                print(f"‚ùå Backup failed: {result.stderr}")
                return False
        except Exception as e:
            print(f"‚ùå Backup error: {e}")
            return False
# ========== ENHANCED MIGRATION FUNCTIONS ==========
@with_session_management
def migrate_with_technical_spec(source_app, target_app, modules=None, backup=True):
    print(f"üõ°Ô∏è TECHNICAL SPEC MIGRATION: {source_app} ‚Üí {target_app}")
    
    analyzer = TechnicalSpecAnalyzer()
    
    analysis = analyzer.analyze_risks()
    
    high_risk_count = len(analysis['high_risk_items'])
    if high_risk_count > 0:
        print(f"‚ö†Ô∏è  FOUND {high_risk_count} HIGH-RISK ITEMS:")
        for item in analysis['high_risk_items'][:3]:
            print(f"   üö® {item['item']} ({item['risk_level']})")
    
    if backup:
        if not analyzer.create_backup():
            print("‚ùå Backup failed - consider proceeding without backup?")
            confirm = input("Continue without backup? (y/N): ")
            if confirm.lower() != 'y':
                return False
    
    return migrate_app_modules_copy(source_app, target_app, modules)

@with_session_management
def analyze_comprehensive(source_app, target_app):
    print(f"üîç COMPREHENSIVE ANALYSIS: {source_app} ‚Üí {target_app}")
    
    compatibility_result = analyze_safe_copy_compatibility(source_app, target_app)
    
    analyzer = TechnicalSpecAnalyzer()
    risk_analysis = analyzer.analyze_risks()
    
    report = {
        'compatibility': compatibility_result,
        'risk_assessment': risk_analysis,
        'recommendation': _generate_recommendation(compatibility_result, risk_analysis)
    }
    
    print(f"üìä COMPREHENSIVE REPORT:")
    print(f"   Compatibility: {'‚úÖ Good' if compatibility_result else '‚ö†Ô∏è Issues'}")
    print(f"   High Risk Items: {len(risk_analysis.get('high_risk_items', []))}")
    print(f"   Recommendation: {report['recommendation']}")
    
    return report

def _generate_recommendation(compatibility, risks):
    high_risks = len(risks.get('high_risk_items', []))
    
    if high_risks > 0 and not compatibility:
        return "üö® HIGH RISK - Not recommended without staging testing"
    elif high_risks > 0:
        return "‚ö†Ô∏è  MEDIUM RISK - Proceed with backup and caution"
    elif compatibility:
        return "‚úÖ LOW RISK - Safe to proceed"
    else:
        return "üü° REVIEW NEEDED - Check compatibility issues"

# ========== INTERACTIVE FUNCTIONS ==========
@with_session_management
def show_site_info():
    print("üåê SITE INFORMATION:")
    print(f"   Site: {frappe.local.site}")
    print(f"   Path: {frappe.get_site_path()}")
    
    try:
        from frappe import __version__
        print(f"   Frappe Version: {__version__}")
    except ImportError:
        print("   Frappe Version: Unknown")
    
    return frappe.local.site

@with_session_management
def show_installed_apps():
    print("\nüì¶ INSTALLED APPLICATIONS:")
    apps = frappe.get_installed_apps()
    
    for i, app in enumerate(apps, 1):
        print(f"   {i}. {app}")
    
    print(f"\n   Total: {len(apps)} apps installed")
    return apps

@with_session_management
def show_app_modules(app_name):
    print(f"\nüìÅ MODULES IN {app_name.upper()}:")
    
    modules = frappe.get_all('Module Def', 
        filters={'app_name': app_name},
        fields=['name', 'module_name', 'app_name'],
        order_by='module_name'
    )
    
    if not modules:
        print(f"   ‚ùå No modules found in {app_name}")
        return []
    
    for i, module in enumerate(modules, 1):
        print(f"   {i}. {module['module_name']}")
    
    print(f"   Total: {len(modules)} modules")
    return modules

def interactive_migration():
    print("üöÄ INTERACTIVE MIGRATION WIZARD")
    print("=" * 50)
    
    site = show_site_info()
    apps = show_installed_apps()
    
    print(f"\nüéØ SELECT SOURCE APP (1-{len(apps)}): ")
    for i, app in enumerate(apps, 1):
        print(f"   {i}. {app}")
    
    try:
        source_choice = int(input("   Enter choice: ")) - 1
        source_app = apps[source_choice]
        print(f"   ‚úÖ Selected source: {source_app}")
    except (ValueError, IndexError):
        print("   ‚ùå Invalid choice")
        return
    
    show_app_modules(source_app)
    
    print(f"\nüéØ SELECT TARGET APP (1-{len(apps)}): ")
    for i, app in enumerate(apps, 1):
        if app != source_app:
            print(f"   {i}. {app}")
    
    try:
        target_choice = int(input("   Enter choice: ")) - 1
        target_app = apps[target_choice]
        
        if target_app == source_app:
            print("   ‚ùå Target app cannot be same as source")
            return
            
        print(f"   ‚úÖ Selected target: {target_app}")
    except (ValueError, IndexError):
        print("   ‚ùå Invalid choice")
        return
    
    print(f"\nüîß MIGRATION OPTIONS:")
    print("   1. Safe Copy Modules (Recommended)")
    print("   2. Technical Spec Migration (With Risk Assessment)")
    print("   3. Comprehensive Analysis Only")
    
    try:
        option_choice = int(input("   Enter choice (1-3): "))
        
        if option_choice == 1:
            migrate_app_modules_copy(source_app, target_app)
        elif option_choice == 2:
            migrate_with_technical_spec(source_app, target_app)
        elif option_choice == 3:
            analyze_comprehensive(source_app, target_app)
        else:
            print("   ‚ùå Invalid choice")
            
    except ValueError as e:
        print(f"   ‚ùå Error: {e}")

# ========== COMMAND HANDLER ==========
@click.command('migrate-app')
@click.argument('action')
@click.argument('source_app', required=False)
@click.argument('target_app', required=False)
@click.option('--modules', help='Specific modules to migrate')
@click.option('--doctypes', help='Specific doctypes to migrate')
@click.option('--site', help='Site name')
@click.option('--backup/--no-backup', default=True, help='Create backup before migration')
def migrate_app(action, source_app=None, target_app=None, modules=None, doctypes=None, site=None, backup=True):
    """App Migrator v3.0 - Complete Toolkit"""
    
    print(f"üöÄ MIGRATION COMMAND: {action}")
    
    if action == 'interactive':
        interactive_migration()
        
    elif action == 'show-site':
        show_site_info()
        
    elif action == 'show-apps':
        show_installed_apps()
        
    elif action == 'show-modules':
        if not source_app:
            print("‚ùå App name required")
            return
        show_app_modules(source_app)
    
    # Technical Spec Commands
    elif action == 'tech-spec-migrate':
        if not source_app or not target_app:
            print("‚ùå Source and target app required")
            return
        migrate_with_technical_spec(source_app, target_app, modules, backup)
        
    elif action == 'comprehensive-analysis':
        if not source_app or not target_app:
            print("‚ùå Source and target app required")
            return
        analyze_comprehensive(source_app, target_app)
        
    elif action == 'risk-report':
        # FIX: Use session management for risk report
        @with_session_management
        def generate_risk_report():
            analyzer = TechnicalSpecAnalyzer(site or frappe.local.site)
            return analyzer.analyze_risks()
        
        analysis = generate_risk_report()
        if analysis:
            print(json.dumps(analysis, indent=2, default=str))
        else:
            print("‚ùå Failed to generate risk report")
        
    elif action == 'create-backup':
        analyzer = TechnicalSpecAnalyzer(site)
        analyzer.create_backup()
    
    # Original Commands
    elif action == 'safe-copy-modules':
        if not source_app or not target_app:
            print("‚ùå Source and target app required")
            return
        migrate_app_modules_copy(source_app, target_app, modules)
        
    elif action == 'analyze-copy-compatibility':
        if not source_app or not target_app:
            print("‚ùå Source and target app required")
            return
        analyze_safe_copy_compatibility(source_app, target_app)
        
    else:
        print(f"‚ùå Unknown action: {action}")
        print("Available actions: interactive, show-site, show-apps, show-modules, tech-spec-migrate, comprehensive-analysis, safe-copy-modules, analyze-copy-compatibility, risk-report, create-backup")

# Export commands
commands = [migrate_app]
# ========== VERSION INFO ==========
__version__ = "3.0.0"  # Enhanced with Technical Specification
